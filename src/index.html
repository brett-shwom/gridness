<!DOCTYPE html>
<html>
<head>
<link rel='stylesheet' href='cssreset-min.css' type='text/css'>
<link rel='stylesheet' href='style.css' type='text/css'>
<script src='ractive.js'></script>
<script src='aggregate-functions.js'></script>
<script src='mock-data.js'></script>
</head>
<body>
<script type='text/template' id='template'>
  <div class='table-container' >
    <table on-wheel='wheel' on-mousewheel='wheel'>
      <thead>
        <tr>
          {{#columns}}
          <td>{{.}}</td>
          {{/columns}}
        </tr>
      </thead>
      <tbody>

        {{#frozenRows}}
          {{>row}}
        {{/frozenRows}}
      
        {{#virtualRows}} 

          {{>row}}
       
        
        {{/virtualRows}}

      </tbody>
    </table>

  </div>
</script>
<script type='text/template' id='rowTemplate'>
        {{# __type__ === 'header'}}

        <tr style='background-color:green; cursor:pointer;' class='{{__frozen__ ? "frozen" : ""}}' on-click='toggleGroupingVisibility' data-key='{{key}}'>
          <td>Key : {{key}}</td>
        </tr>

        {{/ __type__ === 'header' }}
        
        {{# __type__ === undefined }}

        <tr class='{{__frozen__ ? "frozen" : ""}}' >
            {{#.}}
              <td>{{index}}</td>
              <td>{{name}}</td>
              <td>{{address}}</td>
              <td>{{city}}</td>
              <td>{{state}}</td> 
              <td>{{telephone}}</td>
            {{/.}}
        </tr>

        {{/ __type__ === undefined}}
      

        {{# __type__ === 'footer'}}
        
        <tr><td>Sum</td><td>{{sum['index']}}</td></tr>

        {{/ __type__ === 'footer'}}
</script>

<div id='container'></div>

<script >



  var rows = MockData.generateRows()
  var columns = MockData.generateColumns()

  
  var aggregationBeforeFlattening = Aggregate //cache this + reflatten it every time an aggregation is hidden/shown -- flattening is cheap!
    .groupBy(rows, 'telephone')
    .sum("index")
    .header()
    .footer()

  startTime = new Date

  var projectedRows = aggregationBeforeFlattening
    .flatten()

  console.log('time taken to flatten ' + (projectedRows.length).toLocaleString() + ' rows', (startTime.getTime() - (new Date).getTime())/1000)


  var start = 0
  var virtualWindowSize = 10

  //console.log(projectedRows)

  ractive = new Ractive({
    el  : document.querySelector('#container'),
    debug : true,
    twoway :false,
    data : {
      virtualRows : [],//the call to sliceData() will initialize this
      //memoize : memoize,
      frozenRows : [],
      invisibleGroups : {},
      columns : columns
    }, 
    partials : {
      row : document.querySelector('#rowTemplate').innerHTML
    },
    template : document.querySelector('#template').innerHTML,
    magic : true
  })

  function freeze(topNRows) {
    ractive.set('frozenRows', ractive.get('virtualRows').slice(0,topNRows).map(function (row) { //i feel like this should go into aggregate-functions.js
      return Object.create(row, {
         __frozen__ : {
                  value: true,
                  writable: true,
                  enumerable: true,
                  configurable: true //ractive magic mode gets angry if this is false 
            }
      })
    }))
  }

  function reflatten() {
    projectedRows = aggregationBeforeFlattening
      .flatten(ractive.get('invisibleGroups'))

    sliceData(start, start+virtualWindowSize - ractive.get('frozenRows').length)
  }

  ractive.observe('invisibleGroups', function () {
    reflatten()
  })

  ractive.observe('frozenRows', function () {
    reflatten()
  })
  

  //http://stackoverflow.com/a/11252120
  function getElementScrollScale(domElement){
    return domElement.scrollTop / (domElement.scrollHeight - domElement.clientHeight);
  }
  
  ractive.on({
    scrolling : function () {
      var scrollScale = getElementScrollScale(virtualScrollPane)
        , start = scrollScale * (rows.length - numberOfRowsToShow) //do i need to round this?
        , end = start + numberOfRowsToShow
        
      sliceData(start,end)
    },
    wheel : function (e) {
      console.log('wheel')


      var deltaY = e.original.deltaY !== undefined ? e.original.deltaY : -1 * (e.original.wheelDeltaY)
      var deltaX = e.original.deltaX !== undefined ? e.original.deltaX : -1 * (e.original.wheelDeltaX)


      if (deltaY > 0) deltaY = 1
      if (deltaY < 0) deltaY = -1
      if (deltaY === 0) return

      if (start + deltaY < 0) return
      if (start + virtualWindowSize + deltaY > projectedRows.length - 1) return

      start += deltaY


      sliceData(start, start+virtualWindowSize - ractive.get('frozenRows').length)
    },
    toggleGroupingVisibility : function (event) {
      console.log('tt')
      var group = event.context

      ractive.toggle('invisibleGroups.' + group.key) //a bit of ractive keypath fun


    },
    clicked : function (event) {

     // Not working properly at the moment

     // var y = event.original.offsetY - ractive.find('.virtual-scroll-pane').scrollTop
     // var x = event.original.offsetX
     
     // var evt = document.createEvent('MouseEvent');
     //    evt.initMouseEvent('click', true, true, window, 0, screenX, screenY, x, y, true, false, false, true, 0, null);

     
     // ractive.find('.table-container table')
     
    }
  })
  
  
  function sliceData(start,end) {
    ractive.merge('virtualRows', projectedRows.slice(start,end))
  }
  
  sliceData(start, virtualWindowSize)
  
</script>
</body>
</html>
